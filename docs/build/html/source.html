

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sources (martini.sources) &mdash; MARTINI 1.0.4 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Beam Models (martini.beams)" href="beam.html" />
    <link rel="prev" title="Data Cube (martini.DataCube)" href="datacube.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> MARTINI
          

          
          </a>

          
            
            
              <div class="version">
                1.0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="includeme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="martini.html">Martini (martini.Martini)</a></li>
<li class="toctree-l1"><a class="reference internal" href="datacube.html">Data Cube (martini.DataCube)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sources (martini.sources)</a></li>
<li class="toctree-l1"><a class="reference internal" href="beam.html">Beam Models (martini.beams)</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noise Models (martini.noise)</a></li>
<li class="toctree-l1"><a class="reference internal" href="spectral_model.html">Spectral Models (martini.spectral_models)</a></li>
<li class="toctree-l1"><a class="reference internal" href="sph_kernel.html">SPH Kernels (martini.sph_kernels)</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MARTINI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Sources (martini.sources)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/source.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-martini.sources">
<span id="sources-martini-sources"></span><h1>Sources (martini.sources)<a class="headerlink" href="#module-martini.sources" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="martini.sources.CrossSource">
<em class="property">class </em><code class="descclassname">martini.sources.</code><code class="descname">CrossSource</code><span class="sig-paren">(</span><em>distance=&lt;Quantity 3. Mpc&gt;, rotation={'rotmat': array([[1., 0., 0.],        [0., 1., 0.],        [0., 0., 1.]])}, ra=&lt;Quantity 0. deg&gt;, dec=&lt;Quantity 0. deg&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#CrossSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.CrossSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a source consisting of 4 particles arrayed in an asymmetric cross.</p>
<p>A simple test source consisting of four particles will be created. Each has
a mass of 10^4 Msun, a SPH smoothing length of 1 kpc, a temperature of
10^4 K, and will be placed in the Hubble flow assuming h=.7 and a distance
of 3 Mpc. Particle coordinates in kpc are
[[0,  1,  0],
[0,  0,  2],
[0, -3,  0],
[0,  0, -4]]
and velocities in km/s are
[[0,  0,  1],
[0, -1,  0],
[0,  0, -1],
[0,  1,  0]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with units of length</span></dt>
<dd><p class="first last">Source distance, also used to place the source in the Hubble flow
assuming h = 0.7.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys may be any combination of ‘axis_angle’, ‘rotmat’ and/or
‘L_coords’. These will be applied in this order. Note that the ‘y-z’
plane will be the one eventually placed in the plane of the “sky”. The
corresponding values:
- ‘axis_angle’ : 2-tuple, first element one of ‘x’, ‘y’, ‘z’ for the         axis to rotate about, second element an astropy.units.Quantity with         dimensions of angle, indicating the angle to rotate through.
- ‘rotmat’ : A (3, 3) numpy.array specifying a rotation.
- ‘L_coords’ : A 2-tuple containing an inclination and an azimuthal         angle (both astropy.units.Quantity instances with dimensions of         angle). The routine will first attempt to identify a preferred         plane based on the angular momenta of the central 1/3 of particles         in the source. This plane will then be rotated to lie in the plane         of the “sky” (‘y-z’), rotated by the azimuthal angle about its         angular momentum pole (rotation about ‘x’), and inclined (rotation         about ‘y’).</p>
</dd>
<dt><strong>ra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Right ascension for the source centroid.</p>
</dd>
<dt><strong>dec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Declination for the source centroid.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">CrossSource</span></dt>
<dd><p class="first last">An appropriately initialized CrossSource object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="martini.sources.SOSource">
<em class="property">class </em><code class="descclassname">martini.sources.</code><code class="descname">SOSource</code><span class="sig-paren">(</span><em>distance=&lt;Quantity 3. Mpc&gt;</em>, <em>rotation={'L_coords': (&lt;Quantity 60. deg&gt;</em>, <em>&lt;Quantity 0. deg&gt;)}</em>, <em>ra=&lt;Quantity 0. deg&gt;</em>, <em>dec=&lt;Quantity 0. deg&gt;</em>, <em>SO_args=None</em>, <em>SO_instance=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SOSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SOSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Class abstracting HI sources using the SimObj package for interface to
simulation data.</p>
<p>This class accesses simulation data via the SimObj package
(<a class="reference external" href="https://github.com/kyleaoman/simobj">https://github.com/kyleaoman/simobj</a>); see the documentation of that
package for further configuration instructions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of length</span></dt>
<dd><p class="first last">Source distance, also used to set the velocity offset via Hubble’s law.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys may be any combination of ‘axis_angle’, ‘rotmat’ and/or
‘L_coords’. These will be applied in this order. Note that the ‘y-z’
plane will be the one eventually placed in the plane of the “sky”. The
corresponding values:
- ‘axis_angle’ : 2-tuple, first element one of ‘x’, ‘y’, ‘z’ for the         axis to rotate about, second element an astropy.units.Quantity with         dimensions of angle, indicating the angle to rotate through.
- ‘rotmat’ : A (3, 3) numpy.array specifying a rotation.
- ‘L_coords’ : A 2-tuple containing an inclination and an azimuthal         angle (both astropy.units.Quantity instances with dimensions of         angle). The routine will first attempt to identify a preferred plane         based on the angular momenta of the central 1/3 of particles in the         source. This plane will then be rotated to lie in the plane of the         “sky” (‘y-z’), rotated by the azimuthal angle about its angular         momentum pole (rotation about ‘x’), and inclined (rotation about ‘y’).</p>
</dd>
<dt><strong>ra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Right ascension for the source centroid.</p>
</dd>
<dt><strong>dec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Declination for the source centroid.</p>
</dd>
<dt><strong>SO_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of keyword arguments to pass to a call to simobj.SimObj.
Arguments are: ‘obj_id’, ‘snap_id’, ‘mask_type’, ‘mask_args’,
‘mask_kwargs’, ‘configfile’, ‘simfiles_configfile’, ‘ncpu’. See simobj
package documentation for details. Provide SO_args or SO_instance, not
both.</p>
</dd>
<dt><strong>SO_instance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SimObj instance</span></dt>
<dd><p class="first last">An initialized SimObj object. Provide SO_instance or SO_args, not both.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SOSource</span></dt>
<dd><p class="first last">An appropriately initialized SOSource object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="martini.sources.SPHSource">
<em class="property">class </em><code class="descclassname">martini.sources.</code><code class="descname">SPHSource</code><span class="sig-paren">(</span><em>distance=&lt;Quantity 3. Mpc&gt;, rotation={'rotmat': array([[1., 0., 0.],        [0., 1., 0.],        [0., 0., 1.]])}, ra=&lt;Quantity 0. deg&gt;, dec=&lt;Quantity 0. deg&gt;, h=0.7, T_g=None, mHI_g=None, xyz_g=None, vxyz_g=None, hsm_g=None, coordinate_axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SPHSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SPHSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Class abstracting HI emission sources consisting of SPH simulation
particles.</p>
<p>This class constructs an HI emission source from arrays of SPH particle
properties: mass, smoothing length, temperature, position, and velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of length</span></dt>
<dd><p class="first last">Source distance, also used to set the velocity offset via Hubble’s law.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys may be any combination of ‘axis_angle’, ‘rotmat’ and/or
‘L_coords’. These will be applied in this order. Note that the ‘y-z’
plane will be the one eventually placed in the plane of the “sky”. The
corresponding values:
- ‘axis_angle’ : 2-tuple, first element one of ‘x’, ‘y’, ‘z’ for the         axis to rotate about, second element an astropy.units.Quantity with         dimensions of angle, indicating the angle to rotate through.
- ‘rotmat’ : A (3, 3) numpy.array specifying a rotation.
- ‘L_coords’ : A 2-tuple containing an inclination and an azimuthal         angle (both astropy.units.Quantity instances with dimensions of         angle). The routine will first attempt to identify a preferred plane         based on the angular momenta of the central 1/3 of particles in the         source. This plane will then be rotated to lie in the plane of the         “sky” (‘y-z’), rotated by the azimuthal angle about its angular         momentum pole (rotation about ‘x’), and inclined (rotation about ‘y’).</p>
</dd>
<dt><strong>ra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Right ascension for the source centroid.</p>
</dd>
<dt><strong>dec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Declination for the source centroid.</p>
</dd>
<dt><strong>h</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Dimensionless hubble constant, H0 = h * 100 km / s / Mpc.</p>
</dd>
<dt><strong>T_g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quatity, with dimensions of temperature</span></dt>
<dd><p class="first last">Particle temperature.</p>
</dd>
<dt><strong>mHI_g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.unit.Quantity, with dimensions of mass</span></dt>
<dd><p class="first last">Particle HI mass.</p>
</dd>
<dt><strong>xyz_g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity array of length 3, with dimensions of length</span></dt>
<dd><p class="first last">Particle position offset from source centroid. Note that the ‘y-z’
plane is that eventually placed in the plane of the “sky”; ‘x’ is
the axis corresponding to the “line of sight”.</p>
</dd>
<dt><strong>vxyz_g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity array of length 3, with dimensions of     velocity</span></dt>
<dd><p class="first last">Particle velocity offset from source centroid. Note that the ‘y-z’
plane is that eventually placed in the plane of the “sky”; ‘x’ is
the axis corresponding to the “line of sight”.</p>
</dd>
<dt><strong>hsm_g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of length</span></dt>
<dd><p class="first last">Particle SPH smoothing lengths.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SPHSource</span></dt>
<dd><p class="first last">An appropriately initialized SPHSource object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#martini.sources.SingleParticleSource" title="martini.sources.SingleParticleSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SingleParticleSource</span></code></a>, <a class="reference internal" href="#martini.sources.CrossSource" title="martini.sources.CrossSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CrossSource</span></code></a>, <a class="reference internal" href="#martini.sources.SOSource" title="martini.sources.SOSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SOSource</span></code></a></p>
</div>
<dl class="method">
<dt id="martini.sources.SPHSource.apply_mask">
<code class="descname">apply_mask</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SPHSource.apply_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SPHSource.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove particles from source arrays according to a mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, containing boolean-like</span></dt>
<dd><p class="first last">Remove particles with indices corresponding to False values from
the source arrays.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="martini.sources.SPHSource.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>axis_angle=None</em>, <em>rotmat=None</em>, <em>L_coords=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SPHSource.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SPHSource.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the source.</p>
<p>The arguments correspond to different rotation types. If supplied
together in one function call, they are applied in order: axis_angle,
then rotmat, then L_coords.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axis_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-tuple</span></dt>
<dd><p class="first last">First element one of ‘x’, ‘y’, ‘z’ for the axis to rotate about,
second element an astropy.units.Quantity with dimensions of angle,
indicating the angle to rotate through.</p>
</dd>
<dt><strong>rotmat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array-like</span></dt>
<dd><p class="first last">Rotation matrix.</p>
</dd>
<dt><strong>L_coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-tuple</span></dt>
<dd><p class="first last">First element containing an inclination and second element an
azimuthal angle (both astropy.units.Quantity instances with
dimensions of angle). The routine will first attempt to identify
a preferred plane based on the angular momenta of the central 1/3
of particles in the source. This plane will then be rotated to lie
in the ‘y-z’ plane, followed by a rotation by the azimuthal angle
about its angular momentum pole (rotation about ‘x’), and finally
inclined (rotation about ‘y’).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="martini.sources.SPHSource.save_current_rotation">
<code class="descname">save_current_rotation</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SPHSource.save_current_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SPHSource.save_current_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Output current rotation matrix to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">filename or file handle</span></dt>
<dd><p class="first last">File in which to save rotation matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="martini.sources.SPHSource.translate_position">
<code class="descname">translate_position</code><span class="sig-paren">(</span><em>translation_vector</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SPHSource.translate_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SPHSource.translate_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the source.</p>
<p>Note that the “line of sight” is along the ‘x’ axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>translation_vector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, shape (3, ), with         dimensions of length</span></dt>
<dd><p class="first last">Vector by which to offset the source particle coordinates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="martini.sources.SPHSource.translate_velocity">
<code class="descname">translate_velocity</code><span class="sig-paren">(</span><em>translation_vector</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SPHSource.translate_velocity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SPHSource.translate_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an offset to the source velocity.</p>
<p>Note that the “line of sight” is along the ‘x’ axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>translation_vector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, shape (3, ), with         dimensions of velocity</span></dt>
<dd><p class="first last">Vector by which to offset the source particle velocities.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="martini.sources.SingleParticleSource">
<em class="property">class </em><code class="descclassname">martini.sources.</code><code class="descname">SingleParticleSource</code><span class="sig-paren">(</span><em>distance=&lt;Quantity 3. Mpc&gt;</em>, <em>ra=&lt;Quantity 0. deg&gt;</em>, <em>dec=&lt;Quantity 0. deg&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#SingleParticleSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.SingleParticleSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Class illustrating inheritance from martini.sources.SPHSource, creates a
single particle test source.</p>
<p>A simple test source consisting of a single particle will be created. The
particle has a mass of 10^4 Msun, a SPH smoothing length of 1 kpc, a
temperature of 10^4 K, a position offset by (x, y, z) = (1 pc, 1 pc, 1 pc)
from the source centroid, a peculiar velocity of 0 km/s, and will be placed
in the Hubble flow assuming h = 0.7 and the distance provided.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with units of length</span></dt>
<dd><p class="first last">Source distance, also used to place the source in the Hubble flow
assuming h = 0.7.</p>
</dd>
<dt><strong>ra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Right ascension for the source centroid.</p>
</dd>
<dt><strong>dec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Declination for the source centroid.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SingleParticleSource</span></dt>
<dd><p class="first last">An appropriately initialized SingleParticleSource object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="martini.sources.TNGSource">
<em class="property">class </em><code class="descclassname">martini.sources.</code><code class="descname">TNGSource</code><span class="sig-paren">(</span><em>basePath</em>, <em>snapNum</em>, <em>subID</em>, <em>distance=&lt;Quantity 3. Mpc&gt;</em>, <em>rotation={'L_coords': (&lt;Quantity 60. deg&gt;</em>, <em>&lt;Quantity 0. deg&gt;)}</em>, <em>ra=&lt;Quantity 0. deg&gt;</em>, <em>dec=&lt;Quantity 0. deg&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/martini/sources.html#TNGSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#martini.sources.TNGSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Class abstracting HI sources designed to run in the IllustrisTNG JupyterLab
environment for access to simulation data. Can also be used in other
environments, but requires that the ‘illustris_python’ module be
importable, and further that the data are laid out on disk in the fiducial
way (see: <a class="reference external" href="http://www.tng-project.org/data/docs/scripts/">http://www.tng-project.org/data/docs/scripts/</a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>basePath</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Directory containing simulation data, for instance ‘TNG100-1/output/’,
see also <a class="reference external" href="http://www.tng-project.org/data/docs/scripts/">http://www.tng-project.org/data/docs/scripts/</a></p>
</dd>
<dt><strong>snapNum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Snapshot number. In TNG, snapshot 99 is the final output. Note that
a full snapshot (not a ‘mini’ snapshot, see
<a class="reference external" href="http://www.tng-project.org/data/docs/specifications/#sec1a">http://www.tng-project.org/data/docs/specifications/#sec1a</a>) must be
used.</p>
</dd>
<dt><strong>subID</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Subhalo ID of the target object. Note that all particles in the FOF
group to which the subhalo belongs are used to construct the data cube.
This avoids strange “holes” at the locations of other subhaloes in the
same group, and gives a more realistic treatment of foreground and
background emission local to the source.</p>
</dd>
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of length</span></dt>
<dd><p class="first last">Source distance, also used to set the velocity offset via Hubble’s law.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys may be any combination of ‘axis_angle’, ‘rotmat’ and/or
‘L_coords’. These will be applied in this order. Note that the ‘y-z’
plane will be the one eventually placed in the plane of the “sky”. The
corresponding values:
- ‘axis_angle’ : 2-tuple, first element one of ‘x’, ‘y’, ‘z’ for the         axis to rotate about, second element an astropy.units.Quantity with         dimensions of angle, indicating the angle to rotate through.
- ‘rotmat’ : A (3, 3) numpy.array specifying a rotation.
- ‘L_coords’ : A 2-tuple containing an inclination and an azimuthal         angle (both astropy.units.Quantity instances with dimensions of         angle). The routine will first attempt to identify a preferred plane         based on the angular momenta of the central 1/3 of particles in the         source. This plane will then be rotated to lie in the plane of the         “sky” (‘y-z’), rotated by the azimuthal angle about its angular         momentum pole (rotation about ‘x’), and inclined (rotation about ‘y’).</p>
</dd>
<dt><strong>ra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Right ascension for the source centroid.</p>
</dd>
<dt><strong>dec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">astropy.units.Quantity, with dimensions of angle</span></dt>
<dd><p class="first last">Declination for the source centroid.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">TNGSource</span></dt>
<dd><p class="first last">An appropriately initialized TNGSource object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="beam.html" class="btn btn-neutral float-right" title="Beam Models (martini.beams)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="datacube.html" class="btn btn-neutral" title="Data Cube (martini.DataCube)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Kyle Oman

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>